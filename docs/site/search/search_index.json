{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"ten ten is a Python library for web exploit development. It provides a set of tools to make your life easier when writing code to test the security of web applications. The GitHub repository is available here . Installation ten can be installed from source using pip or poetry . It requires Python 3.10 or higher. Use poetry to create a virtual environment and install the package: $ poetry install $ poetry shell If you're feeling adventurous, you can also install it with pip . This enables the ten and tf commands system-wide: $ pip install . Quick start Create a template and make the script executable: $ ten script.py This opens a template script with your favorite editor: from ten import * @entry def main(): ... main() Documentation Refer to the python documentation for precise description of all the available classes and methods. Check the menu on the left for quick descriptions of the most used modules, and tutorials.","title":"Home"},{"location":"index.html#ten","text":"ten is a Python library for web exploit development. It provides a set of tools to make your life easier when writing code to test the security of web applications. The GitHub repository is available here .","title":"ten"},{"location":"index.html#installation","text":"ten can be installed from source using pip or poetry . It requires Python 3.10 or higher. Use poetry to create a virtual environment and install the package: $ poetry install $ poetry shell If you're feeling adventurous, you can also install it with pip . This enables the ten and tf commands system-wide: $ pip install .","title":"Installation"},{"location":"index.html#quick-start","text":"Create a template and make the script executable: $ ten script.py This opens a template script with your favorite editor: from ten import * @entry def main(): ... main()","title":"Quick start"},{"location":"index.html#documentation","text":"Refer to the python documentation for precise description of all the available classes and methods. Check the menu on the left for quick descriptions of the most used modules, and tutorials.","title":"Documentation"},{"location":"flow.html","text":"Input, output, and flow control Basics for input, output and flow control. Refer to tenlib.flow 's documentation for details. Input, output, and flow control Input Program arguments Argument types Optional arguments Entry class Documentation Output Basics Changing the display style Flow control Pausing Exiting early Assumptions inform: Status of your functions Input Receiving arguments using sys.argv or argparse can get tedious, especially when you just want to run a quick program. Program arguments To avoid this, the arguments to the main function are mapped to command-line arguments automatically. from ten import * @entry def main(a, b): print('a:', a) print('b:', b) main() You'd call the program like so: $ ./program.py testA testB a: testA b: testB Argument types Another annoying thing when fetching arguments is typing: what if I want an argument to be an integer ? Well, type-hinting is supported. @entry def main(a: int, b: int): c = a + b print(c) You can even use lists: # Note: list[int] requires py3.10 -- For earlier versions, use typing.List[int] @entry def main(all_numbers: list[int]): c = sum(all_numbers) print(c) $ ./program.py 1 2 3 4 10 Optional arguments If your input argument has a default value, its expected type will be the same as the default value, and it will become an optional argument. @entry def main(some_arg, some_number=3, some_string='test'): print('some_arg:', repr(some_arg)) print('some_number:', repr(some_number)) print('some_string', repr(some_string)) The two last arguments will be optional, as can be seen using the --help command. $ ./program.py -h usage: program.py [-h] [-s SOME_INT] [-S SOME_STR] some_arg positional arguments: some_arg optional arguments: -h, --help show this help message and exit -s SOME_INT, --some-int SOME_INT -S SOME_STR, --some-str SOME_STR Example call: $ ./program.py some_value -s 123 some_arg: 'some_value' some_number: 123 some_string: 'test' Entry class For more complex scripts, you might want to use an object instead of a single function. To do so, apply the @entry decorator to the class instead. It'll get instanciated with the program arguments, and its run() method will be called. from ten import * @entry class Exploit: def __init__(self, url: str, workers: int): self.url = url self.workers = workers def run(self): ... Exploit() Generally, the __init__ function only sets values from the arguments. Therefore, @entry synergizes well with @dataclass : from ten import * from dataclasses import dataclass @entry @dataclass class Exploit: url: str workers: int def run(self): session = ScopedSession(url, workers) ... Exploit() Documentation Entrypoint arguments can be documented using the @arg decorator. @entry @arg(\"url\", \"Target URL\") @arg(\"proxy\", \"Proxy URL\") @arg(\"max_connections\", \"Maximum number of connections\") def main(url, proxy=None, max_connections=10): \"\"\"CLI documentation for the program. \"\"\" The --help command will display the documentation: /tmp/l1 --help Usage: l1 [-h] [-p PROXY] [-m MAX_CONNECTIONS] url CLI documentation for the program. Positional Arguments: url Target URL Options: -h, --help show this help message and exit -p, --proxy PROXY Proxy URL -m, --max-connections MAX_CONNECTIONS Maximum number of connections Output Spamming print s works, but it can get hard to read. Use the msg_* functions to display easy to read, identifiable messages. Basics msg_info('This is an informational message') msg_success('This message indicates a success') ... msg_failure('This message indicates a failure.') This displays the line with a prefix: Ten's output is handled by rich library , so you can use its built-in style edition features. msg_info(f'Found this value: [blue]{value}[/]') msg_failure(f'This value is not valid: [red b]{value}[/]'') Changing the display style A few other output styles were implemented. Use set_message_formatter() to set the style you prefer: set_message_formatter(\"Oldschool\") # OR ... set_message_formatter(\"Slick\") # personal favourite those two would yield: Flow control Pausing You can pause execution at any time using pause() . Exiting early Oftentimes in exploits, you want to display a message, then exit, because something didn't go as planned. You can do it in one line using: leave('Exploit done, exiting.') If the reason for the early exit is a failure or an error, you can use the eponym functions: # We want ints only ! a stack trace will be displayed. if not instance(value, int): error('Value should be of type int: {!r}', value) # Cannot exploit with value < 0. Exits, but no stack trace displayed if value < 0: failure('Value is inferior to zero, unexploitable.') Assumptions The same as the assert builtin, but the message gets displayed using msg_failure() , and no stack trace is displayed. assume(value >= 0, f'Value is inferior to zero: {value}') inform: Status of your functions Say you have a slow function in your code. You'd generally end up with something like this: def slow_func(): print('Starting slow_func, might be slow...') # Actually getting stuff done ... if result: print('Result OK !') else: print('Result not OK !') return result With inform , you can let ten handle the output. go gets displayed along with a spinner while the function is running. Then, a different message gets displayed in function of the result. @inform( go=\"Starting slow_func, might be slow...\", ok=\"Result OK !\", ko=\"Result not OK !\", ) def slow_func(): # Actually getting stuff done ... Use the {result} format to incorporate the result in the success/failure message: @inform( \"Counting links in page...\", \"Found {result} links in page\", \"No links were found.\", ) def count_links(url): r = session.get(url) links = r.select(\"a\") return len(links) For single-function programs, you can combine it with @entry : @entry @inform(\"Downloading sources...\", \"Downloaded {result} source files.\") def main(url): ... main()","title":"Flow: Input, output, and flow control"},{"location":"flow.html#input-output-and-flow-control","text":"Basics for input, output and flow control. Refer to tenlib.flow 's documentation for details. Input, output, and flow control Input Program arguments Argument types Optional arguments Entry class Documentation Output Basics Changing the display style Flow control Pausing Exiting early Assumptions inform: Status of your functions","title":"Input, output, and flow control"},{"location":"flow.html#input","text":"Receiving arguments using sys.argv or argparse can get tedious, especially when you just want to run a quick program.","title":"Input"},{"location":"flow.html#program-arguments","text":"To avoid this, the arguments to the main function are mapped to command-line arguments automatically. from ten import * @entry def main(a, b): print('a:', a) print('b:', b) main() You'd call the program like so: $ ./program.py testA testB a: testA b: testB","title":"Program arguments"},{"location":"flow.html#argument-types","text":"Another annoying thing when fetching arguments is typing: what if I want an argument to be an integer ? Well, type-hinting is supported. @entry def main(a: int, b: int): c = a + b print(c) You can even use lists: # Note: list[int] requires py3.10 -- For earlier versions, use typing.List[int] @entry def main(all_numbers: list[int]): c = sum(all_numbers) print(c) $ ./program.py 1 2 3 4 10","title":"Argument types"},{"location":"flow.html#optional-arguments","text":"If your input argument has a default value, its expected type will be the same as the default value, and it will become an optional argument. @entry def main(some_arg, some_number=3, some_string='test'): print('some_arg:', repr(some_arg)) print('some_number:', repr(some_number)) print('some_string', repr(some_string)) The two last arguments will be optional, as can be seen using the --help command. $ ./program.py -h usage: program.py [-h] [-s SOME_INT] [-S SOME_STR] some_arg positional arguments: some_arg optional arguments: -h, --help show this help message and exit -s SOME_INT, --some-int SOME_INT -S SOME_STR, --some-str SOME_STR Example call: $ ./program.py some_value -s 123 some_arg: 'some_value' some_number: 123 some_string: 'test'","title":"Optional arguments"},{"location":"flow.html#entry-class","text":"For more complex scripts, you might want to use an object instead of a single function. To do so, apply the @entry decorator to the class instead. It'll get instanciated with the program arguments, and its run() method will be called. from ten import * @entry class Exploit: def __init__(self, url: str, workers: int): self.url = url self.workers = workers def run(self): ... Exploit() Generally, the __init__ function only sets values from the arguments. Therefore, @entry synergizes well with @dataclass : from ten import * from dataclasses import dataclass @entry @dataclass class Exploit: url: str workers: int def run(self): session = ScopedSession(url, workers) ... Exploit()","title":"Entry class"},{"location":"flow.html#documentation","text":"Entrypoint arguments can be documented using the @arg decorator. @entry @arg(\"url\", \"Target URL\") @arg(\"proxy\", \"Proxy URL\") @arg(\"max_connections\", \"Maximum number of connections\") def main(url, proxy=None, max_connections=10): \"\"\"CLI documentation for the program. \"\"\" The --help command will display the documentation: /tmp/l1 --help Usage: l1 [-h] [-p PROXY] [-m MAX_CONNECTIONS] url CLI documentation for the program. Positional Arguments: url Target URL Options: -h, --help show this help message and exit -p, --proxy PROXY Proxy URL -m, --max-connections MAX_CONNECTIONS Maximum number of connections","title":"Documentation"},{"location":"flow.html#output","text":"Spamming print s works, but it can get hard to read. Use the msg_* functions to display easy to read, identifiable messages.","title":"Output"},{"location":"flow.html#basics","text":"msg_info('This is an informational message') msg_success('This message indicates a success') ... msg_failure('This message indicates a failure.') This displays the line with a prefix: Ten's output is handled by rich library , so you can use its built-in style edition features. msg_info(f'Found this value: [blue]{value}[/]') msg_failure(f'This value is not valid: [red b]{value}[/]'')","title":"Basics"},{"location":"flow.html#changing-the-display-style","text":"A few other output styles were implemented. Use set_message_formatter() to set the style you prefer: set_message_formatter(\"Oldschool\") # OR ... set_message_formatter(\"Slick\") # personal favourite those two would yield:","title":"Changing the display style"},{"location":"flow.html#flow-control","text":"","title":"Flow control"},{"location":"flow.html#pausing","text":"You can pause execution at any time using pause() .","title":"Pausing"},{"location":"flow.html#exiting-early","text":"Oftentimes in exploits, you want to display a message, then exit, because something didn't go as planned. You can do it in one line using: leave('Exploit done, exiting.') If the reason for the early exit is a failure or an error, you can use the eponym functions: # We want ints only ! a stack trace will be displayed. if not instance(value, int): error('Value should be of type int: {!r}', value) # Cannot exploit with value < 0. Exits, but no stack trace displayed if value < 0: failure('Value is inferior to zero, unexploitable.')","title":"Exiting early"},{"location":"flow.html#assumptions","text":"The same as the assert builtin, but the message gets displayed using msg_failure() , and no stack trace is displayed. assume(value >= 0, f'Value is inferior to zero: {value}')","title":"Assumptions"},{"location":"flow.html#inform-status-of-your-functions","text":"Say you have a slow function in your code. You'd generally end up with something like this: def slow_func(): print('Starting slow_func, might be slow...') # Actually getting stuff done ... if result: print('Result OK !') else: print('Result not OK !') return result With inform , you can let ten handle the output. go gets displayed along with a spinner while the function is running. Then, a different message gets displayed in function of the result. @inform( go=\"Starting slow_func, might be slow...\", ok=\"Result OK !\", ko=\"Result not OK !\", ) def slow_func(): # Actually getting stuff done ... Use the {result} format to incorporate the result in the success/failure message: @inform( \"Counting links in page...\", \"Found {result} links in page\", \"No links were found.\", ) def count_links(url): r = session.get(url) links = r.select(\"a\") return len(links) For single-function programs, you can combine it with @entry : @entry @inform(\"Downloading sources...\", \"Downloaded {result} source files.\") def main(url): ... main()","title":"inform: Status of your functions"},{"location":"fs.html","text":"Filesystem (files, directories) Quickly access and edit files. Refer to tenlib.fs 's documentation for details. The FS module has a few functions to quickly manipulate files: from ten import * if exists(\"/tmp/test.txt\"): data = read_text(\"/tmp/test.txt\") else: data = compute() write(\"/tmp/test.txt\", data) For advanced usage, use Path instead: path = Path(\"/tmp/test.txt\") if path.exists(): data = path.read_text() else: data = compute() path.write(data) Files Create a Path object, a wrapper for pathlib.Path with a few additional methods. p = Path(\"/tmp/test.txt\") Read and write To read data as a string or bytes: contents = p.read_text() contents = p.read_bytes() To write data as bytes or string, use the Path.write() method. p.write(b\"contents\") p.write(\"contents\") To append, use Path.append() : p.append(\"additional contents\") Creating a file Create a file using Path.touch() . p.touch() To create the whole directory hierarchy, use parents=True , or simply ptouch() : p = Path(\"/tmp/long/path/to/file\") # equivalent p.touch(parents=True) p.ptouch() The call returns the instance, so it can be chained with write() , for instance. p.ptouch().write(\"data\") Directories To go through a directory, use glob() or rglob() . dir = Path(\"./dir\") for file in dir.rglob(\"**/*.py\"): msg_info(f\"Found python file: {file}\") process_file(file) Create a directory using mkdir() : dir = Path(\"./dir\") dir.mkdir() To create the parent directories as well, use mkdir(parent=True) .","title":"Filesystem: manage folders and files"},{"location":"fs.html#filesystem-files-directories","text":"Quickly access and edit files. Refer to tenlib.fs 's documentation for details. The FS module has a few functions to quickly manipulate files: from ten import * if exists(\"/tmp/test.txt\"): data = read_text(\"/tmp/test.txt\") else: data = compute() write(\"/tmp/test.txt\", data) For advanced usage, use Path instead: path = Path(\"/tmp/test.txt\") if path.exists(): data = path.read_text() else: data = compute() path.write(data)","title":"Filesystem (files, directories)"},{"location":"fs.html#files","text":"Create a Path object, a wrapper for pathlib.Path with a few additional methods. p = Path(\"/tmp/test.txt\")","title":"Files"},{"location":"fs.html#read-and-write","text":"To read data as a string or bytes: contents = p.read_text() contents = p.read_bytes() To write data as bytes or string, use the Path.write() method. p.write(b\"contents\") p.write(\"contents\") To append, use Path.append() : p.append(\"additional contents\")","title":"Read and write"},{"location":"fs.html#creating-a-file","text":"Create a file using Path.touch() . p.touch() To create the whole directory hierarchy, use parents=True , or simply ptouch() : p = Path(\"/tmp/long/path/to/file\") # equivalent p.touch(parents=True) p.ptouch() The call returns the instance, so it can be chained with write() , for instance. p.ptouch().write(\"data\")","title":"Creating a file"},{"location":"fs.html#directories","text":"To go through a directory, use glob() or rglob() . dir = Path(\"./dir\") for file in dir.rglob(\"**/*.py\"): msg_info(f\"Found python file: {file}\") process_file(file) Create a directory using mkdir() : dir = Path(\"./dir\") dir.mkdir() To create the parent directories as well, use mkdir(parent=True) .","title":"Directories"},{"location":"http.html","text":"HTTP: requests on steroids The HTTP module is implemented on top of requests , but provides additional features. Refer to tenlib.http 's documentation for details. HTTP: requests on steroids Example comparison requests/ten Session Creating a standard session and issuing HTTP requests Creating a scoped session Setting a proxy Proxying through Burp Raw URLs HTTP Responses Status code Text matching Regular expressions BeautifulSoup: checking the DOM Forms Getting a form Setting form values Sending the form Multi, First, Pool: Send concurrent requests Multi: run all concurrent requests First: stop as soon as one request succeeds Pool: advanced concurrency Example comparison requests/ten Let's say you want to log in as an administrator on a Drupal website. You want to proxy the traffic through Burp to check if everything works correctly. With requests , you'd have the following script: import requests import re URL = 'http://site.com' def main(): session = Session() session.verify = False session.proxies = {'http': 'localhost:8080', 'https': 'localhost:8080'} # GET request to get CSRF token, form ID, etc. response = session.get(URL + '/user/login') form_build_id = re.search('name=\"form_build_id\" value=\"(.*?)\"', response.text).group(1) form_token = re.search('name=\"form_token\" value=\"(.*?)\"', response.text).group(1) form_id = re.search('name=\"form_id\" value=\"(.*?)\"', response.text).group(1) # Log in response = session.post( URL + '/user/login', data={ 'user': 'someone', 'pass': 'password1!' 'form_build_id': form_build_id, 'form_token': form_token, 'form_id': form_id, } } if response.status_code != 200: print('Unable to log in') exit() if 'Welcome, admin' not in response.text: print('User is not an administrator') exit() print('Login successful !') main() With ten , you'd have: from ten import * URL = 'http://site.com' @entry def main(): session = ScopedSession(URL) session.burp() response = session.get('/user/login') form = response.form(id='user-login') form.update({ 'user': 'someone', 'pass': 'password1!' }) response = form.submit() if not response.code(200): failure('Unable to log in') if not response.contains('Welcome, admin'): failure('User is not an administrator') msg_success('Login successful !') main() Faster, and more readable. But that's not all the http module can do. Session Creating a standard session and issuing HTTP requests Create a session like so: session = Session() The API is the same as requests.Session 's API. # Some GET request response = session.get('https://site.com/', headers={...}, ...) # Some POST request response = session.post('https://site.com/user/login', data={...}, ...) Creating a scoped session When you're bound to send several requests to the same website, you often end up having to concat the base URL with the path. Instead, you can use a ScopedSession : session = ScopedSession('http://target.com/admin') You'd call methods like this: # GET http://target.com/admin/login response = await session.get('/login') If you request something that is out of scope, it'll raise an exception: # raises HTTPOutOfScopeError response = await session.get('http://target.com/user') Setting a proxy The standard requests API requires you to set proxies as a dictionary. Now, a string suffices: session.proxies = \"socks5://localhost:8888\" Proxying through Burp If you need to debug some requests, you can call Session.burp() to set the proxy to localhost:8080 . session.burp() When you're done, unset it like so: session.unburp() Raw URLs By default, URL's path is not re-evaluated by ten , allowing the use of non-canonical URLs, or un-encoded URLs: # GET /portal/../admin?param=<xss> HTTP/1.1 response = session.get(\"https://target.com/portal/../admin?param=<xss>\") To go back to the requests behaviour, were the URL is canonicalized and GET parameters are re-encoded, set raw_url to False . session.raw_url = False # GET /admin?param=%3Cxss%3E HTTP/1.1 response = session.get(\"https://target.com/portal/../admin?param=<xss>\") HTTP Responses Upon receiving an HTTP response, one will generally make sure they are OK, using the HTTP status code or looking for keywords in the contents, and then parse their contents to extract data. Status code Comparing the HTTP status code with several: if response.code(200, 302): ... Exiting when an unexpected code happens: response.expect(200) Text matching Use Response.contains() to quickly check for keywords, as string or bytes: if response.contains('login successful'): ... if response.contains(b'login successful'): ... Regular expressions Every response object contains a re property that has the same API as the re module. It handles both str and bytes . match = response.re.search(r'token:([0-9]+)') changed = response.re.sub( br'\\x00\\x00\\x7f.{5}', b'' ) BeautifulSoup: checking the DOM A BeautifulSoup object is available as response.soup : p_tags = response.soup.find('p') In addition, select() and select_one() are access elements using CSS selectors: token = response.select_one('input[name=\"token\"]').attrs[\"value\"] Forms Getting a form Use the Response.form method to extract a form from a response: login_form = response.form(id=\"user-login\") Any combination of HTML attributes can be used to select the form: login_form = response.form(action=\"/user/login\", method=\"POST\") The form method returns a Form object, which contains the form's data, and can be used to submit the form. Form( action='https://www.drupal.org/user/login', method='post', data={ 'name': '', 'pass': '', 'form_build_id': 'form-b2WxheXaaeswzS13Ypq5YhAWMJLRk8-fs_xT9VMceXw', 'form_token': '9l0gj6ZY1OJBZ9I9ZKWvaNetevSRw2e5dHycs7SBzPs', 'form_id': 'user_login', 'op': 'Log in' } ) Setting form values Form values can be read/written as a dict: csrf_token = form[\"token\"] form[\"user\"] = \"test@yopmail.com\" form[\"password\"] = \"Password123!\" or using the update() method: form.update({\"user\": \"test@yopmail.com\", \"password\": \"Password123!\"}) The underlying dictionary is stored in form.data . Sending the form You can then submit the form: response = form.submit() Multi, First, Pool: Send concurrent requests Multi: run all concurrent requests Oftentimes, you'll need to send multiple requests at the same time. For example, when you're fuzzing a parameter, you'll want to send a request for each payload. ten provides helpers to do so, easily, and in a readable way. Say you want to retrieve the first 10 news from a website. You could do it like so: session = ScopedSession(\"https://target.com/\") responses = [session.get(f\"/news/{id}\") for id in range(10)] However, requests are done one after the other, which is inefficient. Using Multi , you can retrieve them concurrently: session = ScopedSession(\"https://target.com/\") responses = session.multi().get(Multi(f\"/news/{id}\" for id in range(10))) The Multi keyword can be anywhere in the call. If you want to issue POST requests to /api/news , with news_id being 0 to 9, you can do: session = ScopedSession(\"https://target.com/\") responses = session.multi().post(\"/api/news\", data={\"news_id\": Multi(range(10))}) Even better, you can use several Multi keywords: # Get news for each month and day of the year 2023 session = ScopedSession(\"https://target.com/\") responses = session.multi().post( \"/api/news\", data={ \"year\": 2023, \"month\": Multi(range(1, 13)), \"day\": Multi(range(1, 32)) } ) This code would produce 12 * 31 requests, all done concurrently. First: stop as soon as one request succeeds Session.multi() will run every request to completion. In some cases, you might want to stop as soon as one request succeeds. For example, when you're fuzzing a parameter, you might want to stop as soon as you find a working payload. You can do so by using Session.first() . def news_exists(r: Response): return r.code(200) and r.contains(\"<title>News id\") first_news = session.first(news_exists).get(Multi(f\"/news/{id}\" for id in range(10))) This code runs requests concurrently until one matches the news_exists predicate. It then returns the first response that matches, and cancel the other requests. Pool: advanced concurrency For more advanced usage, you can use Session.pool() , which produces a Pool object. Pool objects run requests concurrently, and allow you to add requests to the pool, and retrieve responses as they come. with session.pool() as pool: # Queue 10 requests for id in range(10): pool.get(f\"/news/{id}\") # Retrieve responses, in order responses = pool.in_order() In addition, you can get responses as they arrive using pool.as_completed() : with session.pool() as pool: # Queue 10 requests for id in range(10): pool.get(f\"/news/{id}\", tag=id) # Get responses, as they arrive for response in pool.as_completed(): msg_info(f\"Received {response.tag}: {response.status_code}\") The tag argument is optional, and can be used to identify responses. As soon as you leave the with block, all pending requests are cancelled. Use this to keep only some of the responses, and cancel the requests you don't need: with session.pool() as pool: for id in range(100): pool.get(f\"/news/{id}\", tag=id) for response in pool.as_completed(): msg_info(f\"Received {response.tag}: {response.status_code}\") if response.code(200) and response.contains(\"News id\"): break # At this point, all pending requests have been cancelled msg_success(f\"Found a news with ID {response.tag}\") Pool support adding new items while being iterated upon. If you're building some kind of crawler, you might need to add new requests whenever you find directories. Here the sample code for a very simple crawler: s = ScopedSession(url) s.raw_url = False with s.pool() as pool: pool.get(\"/\") done = set() for response in pool.as_completed(): done.add(response.url) msg_info(response.url) # Directory: extract links and add them to the pool if response.contains(\"Index of \"): urls = [a.attrs[\"href\"] for a in response.select(\"a\")] urls = {urljoin(response.url, u) for u in urls} urls = urls - done for url in urls: if s.is_in_scope(url) and url.endswith('/'): pool.get(url) # File else: # Save to disk ? ...","title":"HTTP: requests on steroids"},{"location":"http.html#http-requests-on-steroids","text":"The HTTP module is implemented on top of requests , but provides additional features. Refer to tenlib.http 's documentation for details. HTTP: requests on steroids Example comparison requests/ten Session Creating a standard session and issuing HTTP requests Creating a scoped session Setting a proxy Proxying through Burp Raw URLs HTTP Responses Status code Text matching Regular expressions BeautifulSoup: checking the DOM Forms Getting a form Setting form values Sending the form Multi, First, Pool: Send concurrent requests Multi: run all concurrent requests First: stop as soon as one request succeeds Pool: advanced concurrency","title":"HTTP: requests on steroids"},{"location":"http.html#example-comparison-requeststen","text":"Let's say you want to log in as an administrator on a Drupal website. You want to proxy the traffic through Burp to check if everything works correctly. With requests , you'd have the following script: import requests import re URL = 'http://site.com' def main(): session = Session() session.verify = False session.proxies = {'http': 'localhost:8080', 'https': 'localhost:8080'} # GET request to get CSRF token, form ID, etc. response = session.get(URL + '/user/login') form_build_id = re.search('name=\"form_build_id\" value=\"(.*?)\"', response.text).group(1) form_token = re.search('name=\"form_token\" value=\"(.*?)\"', response.text).group(1) form_id = re.search('name=\"form_id\" value=\"(.*?)\"', response.text).group(1) # Log in response = session.post( URL + '/user/login', data={ 'user': 'someone', 'pass': 'password1!' 'form_build_id': form_build_id, 'form_token': form_token, 'form_id': form_id, } } if response.status_code != 200: print('Unable to log in') exit() if 'Welcome, admin' not in response.text: print('User is not an administrator') exit() print('Login successful !') main() With ten , you'd have: from ten import * URL = 'http://site.com' @entry def main(): session = ScopedSession(URL) session.burp() response = session.get('/user/login') form = response.form(id='user-login') form.update({ 'user': 'someone', 'pass': 'password1!' }) response = form.submit() if not response.code(200): failure('Unable to log in') if not response.contains('Welcome, admin'): failure('User is not an administrator') msg_success('Login successful !') main() Faster, and more readable. But that's not all the http module can do.","title":"Example comparison requests/ten"},{"location":"http.html#session","text":"","title":"Session"},{"location":"http.html#creating-a-standard-session-and-issuing-http-requests","text":"Create a session like so: session = Session() The API is the same as requests.Session 's API. # Some GET request response = session.get('https://site.com/', headers={...}, ...) # Some POST request response = session.post('https://site.com/user/login', data={...}, ...)","title":"Creating a standard session and issuing HTTP requests"},{"location":"http.html#creating-a-scoped-session","text":"When you're bound to send several requests to the same website, you often end up having to concat the base URL with the path. Instead, you can use a ScopedSession : session = ScopedSession('http://target.com/admin') You'd call methods like this: # GET http://target.com/admin/login response = await session.get('/login') If you request something that is out of scope, it'll raise an exception: # raises HTTPOutOfScopeError response = await session.get('http://target.com/user')","title":"Creating a scoped session"},{"location":"http.html#setting-a-proxy","text":"The standard requests API requires you to set proxies as a dictionary. Now, a string suffices: session.proxies = \"socks5://localhost:8888\"","title":"Setting a proxy"},{"location":"http.html#proxying-through-burp","text":"If you need to debug some requests, you can call Session.burp() to set the proxy to localhost:8080 . session.burp() When you're done, unset it like so: session.unburp()","title":"Proxying through Burp"},{"location":"http.html#raw-urls","text":"By default, URL's path is not re-evaluated by ten , allowing the use of non-canonical URLs, or un-encoded URLs: # GET /portal/../admin?param=<xss> HTTP/1.1 response = session.get(\"https://target.com/portal/../admin?param=<xss>\") To go back to the requests behaviour, were the URL is canonicalized and GET parameters are re-encoded, set raw_url to False . session.raw_url = False # GET /admin?param=%3Cxss%3E HTTP/1.1 response = session.get(\"https://target.com/portal/../admin?param=<xss>\")","title":"Raw URLs"},{"location":"http.html#http-responses","text":"Upon receiving an HTTP response, one will generally make sure they are OK, using the HTTP status code or looking for keywords in the contents, and then parse their contents to extract data.","title":"HTTP Responses"},{"location":"http.html#status-code","text":"Comparing the HTTP status code with several: if response.code(200, 302): ... Exiting when an unexpected code happens: response.expect(200)","title":"Status code"},{"location":"http.html#text-matching","text":"Use Response.contains() to quickly check for keywords, as string or bytes: if response.contains('login successful'): ... if response.contains(b'login successful'): ...","title":"Text matching"},{"location":"http.html#regular-expressions","text":"Every response object contains a re property that has the same API as the re module. It handles both str and bytes . match = response.re.search(r'token:([0-9]+)') changed = response.re.sub( br'\\x00\\x00\\x7f.{5}', b'' )","title":"Regular expressions"},{"location":"http.html#beautifulsoup-checking-the-dom","text":"A BeautifulSoup object is available as response.soup : p_tags = response.soup.find('p') In addition, select() and select_one() are access elements using CSS selectors: token = response.select_one('input[name=\"token\"]').attrs[\"value\"]","title":"BeautifulSoup: checking the DOM"},{"location":"http.html#forms","text":"","title":"Forms"},{"location":"http.html#getting-a-form","text":"Use the Response.form method to extract a form from a response: login_form = response.form(id=\"user-login\") Any combination of HTML attributes can be used to select the form: login_form = response.form(action=\"/user/login\", method=\"POST\") The form method returns a Form object, which contains the form's data, and can be used to submit the form. Form( action='https://www.drupal.org/user/login', method='post', data={ 'name': '', 'pass': '', 'form_build_id': 'form-b2WxheXaaeswzS13Ypq5YhAWMJLRk8-fs_xT9VMceXw', 'form_token': '9l0gj6ZY1OJBZ9I9ZKWvaNetevSRw2e5dHycs7SBzPs', 'form_id': 'user_login', 'op': 'Log in' } )","title":"Getting a form"},{"location":"http.html#setting-form-values","text":"Form values can be read/written as a dict: csrf_token = form[\"token\"] form[\"user\"] = \"test@yopmail.com\" form[\"password\"] = \"Password123!\" or using the update() method: form.update({\"user\": \"test@yopmail.com\", \"password\": \"Password123!\"}) The underlying dictionary is stored in form.data .","title":"Setting form values"},{"location":"http.html#sending-the-form","text":"You can then submit the form: response = form.submit()","title":"Sending the form"},{"location":"http.html#multi-first-pool-send-concurrent-requests","text":"","title":"Multi, First, Pool: Send concurrent requests"},{"location":"http.html#multi-run-all-concurrent-requests","text":"Oftentimes, you'll need to send multiple requests at the same time. For example, when you're fuzzing a parameter, you'll want to send a request for each payload. ten provides helpers to do so, easily, and in a readable way. Say you want to retrieve the first 10 news from a website. You could do it like so: session = ScopedSession(\"https://target.com/\") responses = [session.get(f\"/news/{id}\") for id in range(10)] However, requests are done one after the other, which is inefficient. Using Multi , you can retrieve them concurrently: session = ScopedSession(\"https://target.com/\") responses = session.multi().get(Multi(f\"/news/{id}\" for id in range(10))) The Multi keyword can be anywhere in the call. If you want to issue POST requests to /api/news , with news_id being 0 to 9, you can do: session = ScopedSession(\"https://target.com/\") responses = session.multi().post(\"/api/news\", data={\"news_id\": Multi(range(10))}) Even better, you can use several Multi keywords: # Get news for each month and day of the year 2023 session = ScopedSession(\"https://target.com/\") responses = session.multi().post( \"/api/news\", data={ \"year\": 2023, \"month\": Multi(range(1, 13)), \"day\": Multi(range(1, 32)) } ) This code would produce 12 * 31 requests, all done concurrently.","title":"Multi: run all concurrent requests"},{"location":"http.html#first-stop-as-soon-as-one-request-succeeds","text":"Session.multi() will run every request to completion. In some cases, you might want to stop as soon as one request succeeds. For example, when you're fuzzing a parameter, you might want to stop as soon as you find a working payload. You can do so by using Session.first() . def news_exists(r: Response): return r.code(200) and r.contains(\"<title>News id\") first_news = session.first(news_exists).get(Multi(f\"/news/{id}\" for id in range(10))) This code runs requests concurrently until one matches the news_exists predicate. It then returns the first response that matches, and cancel the other requests.","title":"First: stop as soon as one request succeeds"},{"location":"http.html#pool-advanced-concurrency","text":"For more advanced usage, you can use Session.pool() , which produces a Pool object. Pool objects run requests concurrently, and allow you to add requests to the pool, and retrieve responses as they come. with session.pool() as pool: # Queue 10 requests for id in range(10): pool.get(f\"/news/{id}\") # Retrieve responses, in order responses = pool.in_order() In addition, you can get responses as they arrive using pool.as_completed() : with session.pool() as pool: # Queue 10 requests for id in range(10): pool.get(f\"/news/{id}\", tag=id) # Get responses, as they arrive for response in pool.as_completed(): msg_info(f\"Received {response.tag}: {response.status_code}\") The tag argument is optional, and can be used to identify responses. As soon as you leave the with block, all pending requests are cancelled. Use this to keep only some of the responses, and cancel the requests you don't need: with session.pool() as pool: for id in range(100): pool.get(f\"/news/{id}\", tag=id) for response in pool.as_completed(): msg_info(f\"Received {response.tag}: {response.status_code}\") if response.code(200) and response.contains(\"News id\"): break # At this point, all pending requests have been cancelled msg_success(f\"Found a news with ID {response.tag}\") Pool support adding new items while being iterated upon. If you're building some kind of crawler, you might need to add new requests whenever you find directories. Here the sample code for a very simple crawler: s = ScopedSession(url) s.raw_url = False with s.pool() as pool: pool.get(\"/\") done = set() for response in pool.as_completed(): done.add(response.url) msg_info(response.url) # Directory: extract links and add them to the pool if response.contains(\"Index of \"): urls = [a.attrs[\"href\"] for a in response.select(\"a\")] urls = {urljoin(response.url, u) for u in urls} urls = urls - done for url in urls: if s.is_in_scope(url) and url.endswith('/'): pool.get(url) # File else: # Save to disk ? ...","title":"Pool: advanced concurrency"},{"location":"shell.html","text":"Shell commands Shell commands Running a shell command Running a program to completion Running a program in the background Running a program to completion and get its output Misc Running a shell command There are two ways to specify the command you want to run: either with a string or a list of arguments. The two following lines are equivalent: shell.call('cat /etc/passwd') shell.call(('cat', '/etc/passwd')) If you want to use bash-specific constructs such as file redirections or other, you should use the string argument: shell.call('cat /etc/passwd > /tmp/other') # works shell.call(('cat', '/etc/passwd', '>', '/tmp/other')) # does not Running a program to completion Use shell.call() , as described in the previous section. Use shell.stdout or shell.stderr files to get the output: p = shell.call(\"cat /etc/passwd\") contents = p.stdout.read() Running a program in the background If you want to start a command and keep interacting with it, or simply let it run in the background, use shell.run_background() : # Start a program p = shell.background('/bin/slow-program arg0 arg1') # Do some other stuff ... ... # Wait for the program to end p.wait() Running a program to completion and get its output Run a program and gets its output as a string: stdout, stderr = shell.get_output('cat /etc/passwd') or as bytes: stdout, stderr = shell.get_output('cat /etc/passwd', text=False) Misc Both call() and background() return a Popen instance .","title":"Shell: run commands"},{"location":"shell.html#shell-commands","text":"Shell commands Running a shell command Running a program to completion Running a program in the background Running a program to completion and get its output Misc","title":"Shell commands"},{"location":"shell.html#running-a-shell-command","text":"There are two ways to specify the command you want to run: either with a string or a list of arguments. The two following lines are equivalent: shell.call('cat /etc/passwd') shell.call(('cat', '/etc/passwd')) If you want to use bash-specific constructs such as file redirections or other, you should use the string argument: shell.call('cat /etc/passwd > /tmp/other') # works shell.call(('cat', '/etc/passwd', '>', '/tmp/other')) # does not","title":"Running a shell command"},{"location":"shell.html#running-a-program-to-completion","text":"Use shell.call() , as described in the previous section. Use shell.stdout or shell.stderr files to get the output: p = shell.call(\"cat /etc/passwd\") contents = p.stdout.read()","title":"Running a program to completion"},{"location":"shell.html#running-a-program-in-the-background","text":"If you want to start a command and keep interacting with it, or simply let it run in the background, use shell.run_background() : # Start a program p = shell.background('/bin/slow-program arg0 arg1') # Do some other stuff ... ... # Wait for the program to end p.wait()","title":"Running a program in the background"},{"location":"shell.html#running-a-program-to-completion-and-get-its-output","text":"Run a program and gets its output as a string: stdout, stderr = shell.get_output('cat /etc/passwd') or as bytes: stdout, stderr = shell.get_output('cat /etc/passwd', text=False)","title":"Running a program to completion and get its output"},{"location":"shell.html#misc","text":"Both call() and background() return a Popen instance .","title":"Misc"},{"location":"transform.html","text":"Transform: Convert data Exploits need to manipulate data easily: encode it into base64, compute its hash, HTML-decode it, etc. That's what transform is for. Each category of transformation is available as a submodule of transform . When you do from ten import * , transform is imported as tf , and the most used modules, such as json or base64 , are included as root modules. Each category of transformation is available as a submodule of transform . >>> from tenlib.transform import base64, html >>> base64.decode('dGVzdA==') b'test' >>> html.decode('&lt;div&gt;test&lt;/div&gt;') '<div>test</div>' Methods support both bytes and str as input, as well as lists and dicts. Refer to Multiform for more details. Here are a few examples for the most common transformations. JSON python output json.encode({\"a\": \"b\", \"c\": \"d\"}) '{\"a\":\"b\",\"c\":\"d\"}' json.decode('{\"a\": \"b\", \"c\": \"d\"}') {\"a\": \"b\", \"c\": \"d\"} Base 64 encoding (base64) python output base64.encode('test') 'dGVzdA==' base64.decode('dGVzdA==') b'test' Query string (qs) Parse query string and URL-encode/decode. python output qs.parse('k1=v1&k2=v2') {'k1': 'v1', 'k2': 'v2'} qs.unparse({'k1': 'v1', 'k2': 'v2'}) 'k1=v1&k2=v2' qs.decode('%41%42%43%3a%44%45%46') 'ABC:DEF' qs.encode('ABC:DEF') 'ABC%3aDEF' qs.encode_all('ABC:DEF') '%41%42%43%3a%44%45%46' Table Convert data formatted into a table (such as CSV) to a list (of list), and back. This example converts an array of colon separated lines into a table. python output table.split('''\\ username:password:email admin:dUD6s55:admin@site.com moderator:123456!:moderator@site.com user:Password1:user@gmail.com\\ ''', '\\n', ':') [ [b'username', b'password', b'email'], [b'admin', b'dUD6s55', b'admin@site.com'], [b'moderator', b'123456!', b'moderator@site.com'], [b'user', b'Password1', b'user@gmail.com'], ] table.join([ [b'username', b'password', b'email'], [b'admin', b'dUD6s55', b'admin@site.com'], [b'moderator', b'123456!', b'moderator@site.com'], [b'user', b'Password1', b'user@gmail.com'], ], '\\n', ':') '''\\ username:password:email admin:dUD6s55:admin@site.com moderator:123456!:moderator@site.com user:Password1:user@gmail.com\\ ''' Hashing python output hashing.md5('test') '098f6bcd4621d373cade4e832627b4f6' hashing.sha1('test') 'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3' Others Lots of other transforms are available. Refer to the documentation for more details. Multiform As you may have seen, you can feed either bytes or strings to the conversion functions, and they will handle the convertion into the proper type. This behaviour also works with dict s and list s: python output base64.encode('test') 'dGVzdA==' base64.encode(b'test') 'dGVzdA==' base64.encode([ 'test', b'test2', 'test3' ]) [ 'dGVzdA==', 'dGVzdDI=', 'dGVzdDM=' ] qs.decode({ 'k1': '%41%42%43', 'k2': '%44%45%46' }) { 'k1': 'ABC', 'k2': 'DEF' } CLI: the tf program The tf program makes transforms available from the CLI as well: $ echo 'dGVzdA==' | tf base64.decode test The filters can be chained. Here, we convert JSON into an URL-encoded string: $ echo '{\"a\":\"b\",\"c\":\"d\"}' | tf json.decode qs.unparse a=b&c=d Check the --help for further details.","title":"Transform: Convert data"},{"location":"transform.html#transform-convert-data","text":"Exploits need to manipulate data easily: encode it into base64, compute its hash, HTML-decode it, etc. That's what transform is for. Each category of transformation is available as a submodule of transform . When you do from ten import * , transform is imported as tf , and the most used modules, such as json or base64 , are included as root modules. Each category of transformation is available as a submodule of transform . >>> from tenlib.transform import base64, html >>> base64.decode('dGVzdA==') b'test' >>> html.decode('&lt;div&gt;test&lt;/div&gt;') '<div>test</div>' Methods support both bytes and str as input, as well as lists and dicts. Refer to Multiform for more details. Here are a few examples for the most common transformations.","title":"Transform: Convert data"},{"location":"transform.html#json","text":"python output json.encode({\"a\": \"b\", \"c\": \"d\"}) '{\"a\":\"b\",\"c\":\"d\"}' json.decode('{\"a\": \"b\", \"c\": \"d\"}') {\"a\": \"b\", \"c\": \"d\"}","title":"JSON"},{"location":"transform.html#base-64-encoding-base64","text":"python output base64.encode('test') 'dGVzdA==' base64.decode('dGVzdA==') b'test'","title":"Base 64 encoding (base64)"},{"location":"transform.html#query-string-qs","text":"Parse query string and URL-encode/decode. python output qs.parse('k1=v1&k2=v2') {'k1': 'v1', 'k2': 'v2'} qs.unparse({'k1': 'v1', 'k2': 'v2'}) 'k1=v1&k2=v2' qs.decode('%41%42%43%3a%44%45%46') 'ABC:DEF' qs.encode('ABC:DEF') 'ABC%3aDEF' qs.encode_all('ABC:DEF') '%41%42%43%3a%44%45%46'","title":"Query string (qs)"},{"location":"transform.html#table","text":"Convert data formatted into a table (such as CSV) to a list (of list), and back. This example converts an array of colon separated lines into a table. python output table.split('''\\ username:password:email admin:dUD6s55:admin@site.com moderator:123456!:moderator@site.com user:Password1:user@gmail.com\\ ''', '\\n', ':') [ [b'username', b'password', b'email'], [b'admin', b'dUD6s55', b'admin@site.com'], [b'moderator', b'123456!', b'moderator@site.com'], [b'user', b'Password1', b'user@gmail.com'], ] table.join([ [b'username', b'password', b'email'], [b'admin', b'dUD6s55', b'admin@site.com'], [b'moderator', b'123456!', b'moderator@site.com'], [b'user', b'Password1', b'user@gmail.com'], ], '\\n', ':') '''\\ username:password:email admin:dUD6s55:admin@site.com moderator:123456!:moderator@site.com user:Password1:user@gmail.com\\ '''","title":"Table"},{"location":"transform.html#hashing","text":"python output hashing.md5('test') '098f6bcd4621d373cade4e832627b4f6' hashing.sha1('test') 'a94a8fe5ccb19ba61c4c0873d391e987982fbbd3'","title":"Hashing"},{"location":"transform.html#others","text":"Lots of other transforms are available. Refer to the documentation for more details.","title":"Others"},{"location":"transform.html#multiform","text":"As you may have seen, you can feed either bytes or strings to the conversion functions, and they will handle the convertion into the proper type. This behaviour also works with dict s and list s: python output base64.encode('test') 'dGVzdA==' base64.encode(b'test') 'dGVzdA==' base64.encode([ 'test', b'test2', 'test3' ]) [ 'dGVzdA==', 'dGVzdDI=', 'dGVzdDM=' ] qs.decode({ 'k1': '%41%42%43', 'k2': '%44%45%46' }) { 'k1': 'ABC', 'k2': 'DEF' }","title":"Multiform"},{"location":"transform.html#cli-the-tf-program","text":"The tf program makes transforms available from the CLI as well: $ echo 'dGVzdA==' | tf base64.decode test The filters can be chained. Here, we convert JSON into an URL-encoded string: $ echo '{\"a\":\"b\",\"c\":\"d\"}' | tf json.decode qs.unparse a=b&c=d Check the --help for further details.","title":"CLI: the tf program"},{"location":"tutorial.html","text":"Tutorials and examples Wordpress user enumeration Concerns: flow, http Although enumerating wordpress users isn't the most interesting part of a pentest, and it can be done by hundred of scripts, it's an interesting way to learn how to to build a simple script with ten, and then gradually improve it to make it more efficient, cleaner, and well-documented. The goal is to list wordpress users (name and slug) using the well-known technique consisting in iterating over the author parameter: /?author=1 , /?author=2 , etc. First, we'll do the most simple implementation possible. First script First, create a template using: $ ten wordpress-enum.py This opens a template script on your favourite editor. Our script necessarily requires a URL, so let's add the url as an input parameter: @entry def main(url): session = ScopedSession(url) The arguments to the entry function are automatically mapped to CLI input. We can now run: $ ./wordpress-enum.py http://target.com If the author with ID 2 exists, fetching /?author=2 results in a redirect to /author/<slug-of-author>/ . We'll start simple: let's just make a for loop that gets the HTTP response and extracts the slug. ten uses the same API as requests ! We can use session.get to get the response. It does not, by default, follow redirects, however. @entry def main(url): session = ScopedSession(url) for id in range(1, 101): response = session.get(\"/\", params={\"author\": id}) if response.is_redirect: redirect = response.headers[\"location\"] if \"/author/\" in redirect: slug = redirect.split(\"/\")[-2] msg_info(f\"Found author #{id} with slug {slug}\") Let's try out the script: $ ./wordpress-enum.py http://target.com [*] Found author #1 with slug user_smt [*] Found author #3 with slug blogsmt-com [*] Found author #9 with slug y-toma-fr [*] Found author #10 with slug p-tim-fr [*] Found author #11 with slug x-levieux-fr [*] Found author #12 with slug hr-fr It works fine, but we can improve the implementation in many, many ways: Let the user pick the maximum user IDs to try out Get username from the redirect page Run requests concurrently Let the user pick number of concurrent connections Let the user pick a proxy Add information about progress Document the script Let's tackle these one by one. Adding parameters Let's let the user pick the number of user IDs to bruteforce, defaulting to 100. def main(url, max_users=100): session = ScopedSession(url) for id in range(1, max_users + 1): ... It's as simple as this: since the default value is an integer, ten assumes the value needs to be numeric. $ ./wordpress-enum.py http://target.com --max-users=10 [*] Found author #1 with slug user_smt [*] Found author #3 with slug blogsmt-com [*] Found author #9 with slug y-toma-fr [*] Found author #10 with slug p-tim-fr Or, with a shortcut: $ ./wordpress-enum.py http://target.com -m 10 If we removed the default value, we'd have to tell ten that we expect an int using python's typing: def main(url, max_users: int): Get username from the redirect page Generally, after the redirect, we land on the page describing the Wordpress author, and the HTML looks like: <html> ... <title>[name-of-user], author on Wordpress site<title> ... </html> As a result, we can follow the redirect; response = response.follow_redirect() and then use a CSS selector to extract the title's contents: title = response.select_one(\"title\").text As a result, we obtain the username @entry def main(url, max_users=100): session = ScopedSession(url) for id in range(max_users): response = session.get(\"/\", params={\"author\": id}) if response.is_redirect: redirect = response.headers[\"location\"] if \"/author/\" in redirect: slug = redirect.split(\"/\")[-2] response = response.follow_redirect() title = response.select_one(\"title\").text username = title.split(\",\", 1)[0] msg_info(f\"Found author #{id} with slug {slug}: {username}\") Let's refactor the code a little bit to remove indent: @entry def main(url, max_users=100): session = ScopedSession(url) for id in range(max_users): response = session.get(\"/\", params={\"author\": id}) if not response.is_redirect: continue redirect = response.headers[\"location\"] if not \"/author/\" in redirect: continue slug = redirect.split(\"/\")[-2] response = response.follow_redirect() username = response.select_one(\"title\").text.split(\",\", 1)[0] msg_info(f\"Found author #{id} with slug {slug}: {username}\") Running requests concurrently At the moment, we run each HTTP request one by one. We can improve the process by running them concurrently. There are several ways to do this, but since we want to keep each response, we can just use multi() : responses = session.multi().get(\"/\", params={\"author\": Multi(range(1, max_users+1))}) Session.multi() returns a list of responses, where each request is submitted once per value in the Multi() instance. Here, we thus get a request to /?author=1 , /?author=2 , etc. The requests are run concurrently. The requests are then returned in the same order as they were submitted. We then need to iterate over the responses as we did before: for id, response in enumerate(responses, start=1): ... We are here in a simple case were it is easy to find the id from the index of the response in the list: the n th response corresponds to id n . However, sometimes the multis might not be numerical; you can also get this value from the tag element of the response: for response in responses: id = response.tag[\"params\", \"author\"] ... Let user pick number of connections By default, a session maintains, at most, 10 concurrent connections. We might want to let the user pick this themselves: @entry def main(url, max_users=100, max_connections=10): session = ScopedSession(url, max_connections=max_connections) Allow for a proxy While attacking stuff on the internet, you often need to use proxies. Setting Session.proxies to a string automatically uses it for all requests: @entry def main(url, max_users=100, max_connections=10, proxy=None): session = ScopedSession(url, max_connections=max_connections) session.proxies = proxy We now have a pretty clean script with a few customizable options. Let's make the script ready for release with a cleaner GUI, documentation, etc. Add a progress bar Multi can display a progress bar indicating its progress. Simply add a description argument describing what is happening: @entry def main(url, max_users=100, max_connections=10): session = ScopedSession(url, max_connections=max_connections) responses = session.multi( description=\"Bruteforcing author IDs\" ).get(\"/\", params={\"author\": Multi(range(max_users))}) Now, you get a beautiful progress bar while the process is running. The second step of the exploitation, which resolves the redirects, should be faster, so it does not need a progress bar. Let's just add a spinner to point out that it is running: with msg_status(\"Resolving usernames...\"): for response in responses: ... Documentation Our program is now fast and it looks good. We need to handle the most dreaded step of development: documentation. If we run --help right now, we get the strict minimum: ./wordpress-enum.py --help Usage: wordpress-enum.py [-h] [-m MAX_USERS] [-M MAX_CONNECTIONS] [-p PROXY] url Positional Arguments: url Options: -h, --help show this help message and exit -m, --max-users MAX_USERS -M, --max-connections MAX_CONNECTIONS -p, --proxy PROXY We'll document the script and its parameters in a blink. Let's start by adding a documentation to the main entrypoint. @entry def main(url, max_users=100, max_connections=10, proxy=None): \"\"\"Obtains Wordpress user slugs and usernames by bruteforcing author IDs. \"\"\" The help message gets a little bit better. However, we should also document arguments. This can be done by using arg(\"name\", \"description\") : @entry @arg(\"url\", \"URL of the WP website\") @arg(\"max_users\", \"Maximum amount of user IDs to bruteforce\") @arg(\"max_connections\", \"Maximum number of concurrent connections\") @arg(\"proxy\", \"Optional proxy to use\") def main(url, max_users=100, max_connections=10, proxy=None): \"\"\"Obtains Wordpress user slugs and usernames by bruteforcing author IDs. \"\"\" That's it ! Our program is documented, and ready for release. ./wordpress-enum.py --help Usage: wordpress-enum.py [-h] [-m MAX_USERS] [-M MAX_CONNECTIONS] [-p PROXY] url Obtains Wordpress user slugs and usernames by bruteforcing author IDs. Positional Arguments: url URL of the WP website Options: -h, --help show this help message and exit -m, --max-users MAX_USERS Maximum amount of user IDs to bruteforce -M, --max-connections MAX_CONNECTIONS Maximum number of concurrent connections -p, --proxy PROXY Optional proxy to use We are ready to go ! Here's the final script: #!/usr/bin/env python3 from ten import * @entry @arg(\"url\", \"URL of the WP website\") @arg(\"max_users\", \"Maximum amount of user IDs to bruteforce\") @arg(\"max_connections\", \"Maximum number of concurrent connections\") @arg(\"proxy\", \"Optional proxy to use\") def main(url, max_users=100, max_connections=10, proxy=None): \"\"\"Obtains Wordpress user slugs and usernames by bruteforcing author IDs. \"\"\" session = ScopedSession(url, max_connections=max_connections) session.proxies = proxy responses = session.multi( description=\"Bruteforcing author IDs\" ).get(\"/\", params={\"author\": Multi(range(max_users))}) with msg_status(\"Resolving usernames...\"): for response in responses: id = response.tag[\"params\", \"author\"] if not response.is_redirect: continue redirect = response.headers[\"location\"] if not \"/author/\" in redirect: continue slug = redirect.split(\"/\")[-2] response = response.follow_redirect() username = response.select_one(\"title\").text.split(\",\", 1)[0] msg_info(f\"Found author #{id} with slug {slug}: {username}\") main()","title":"Tutorials and examples"},{"location":"tutorial.html#tutorials-and-examples","text":"","title":"Tutorials and examples"},{"location":"tutorial.html#wordpress-user-enumeration","text":"Concerns: flow, http Although enumerating wordpress users isn't the most interesting part of a pentest, and it can be done by hundred of scripts, it's an interesting way to learn how to to build a simple script with ten, and then gradually improve it to make it more efficient, cleaner, and well-documented. The goal is to list wordpress users (name and slug) using the well-known technique consisting in iterating over the author parameter: /?author=1 , /?author=2 , etc. First, we'll do the most simple implementation possible.","title":"Wordpress user enumeration"},{"location":"tutorial.html#first-script","text":"First, create a template using: $ ten wordpress-enum.py This opens a template script on your favourite editor. Our script necessarily requires a URL, so let's add the url as an input parameter: @entry def main(url): session = ScopedSession(url) The arguments to the entry function are automatically mapped to CLI input. We can now run: $ ./wordpress-enum.py http://target.com If the author with ID 2 exists, fetching /?author=2 results in a redirect to /author/<slug-of-author>/ . We'll start simple: let's just make a for loop that gets the HTTP response and extracts the slug. ten uses the same API as requests ! We can use session.get to get the response. It does not, by default, follow redirects, however. @entry def main(url): session = ScopedSession(url) for id in range(1, 101): response = session.get(\"/\", params={\"author\": id}) if response.is_redirect: redirect = response.headers[\"location\"] if \"/author/\" in redirect: slug = redirect.split(\"/\")[-2] msg_info(f\"Found author #{id} with slug {slug}\") Let's try out the script: $ ./wordpress-enum.py http://target.com [*] Found author #1 with slug user_smt [*] Found author #3 with slug blogsmt-com [*] Found author #9 with slug y-toma-fr [*] Found author #10 with slug p-tim-fr [*] Found author #11 with slug x-levieux-fr [*] Found author #12 with slug hr-fr It works fine, but we can improve the implementation in many, many ways: Let the user pick the maximum user IDs to try out Get username from the redirect page Run requests concurrently Let the user pick number of concurrent connections Let the user pick a proxy Add information about progress Document the script Let's tackle these one by one.","title":"First script"},{"location":"tutorial.html#adding-parameters","text":"Let's let the user pick the number of user IDs to bruteforce, defaulting to 100. def main(url, max_users=100): session = ScopedSession(url) for id in range(1, max_users + 1): ... It's as simple as this: since the default value is an integer, ten assumes the value needs to be numeric. $ ./wordpress-enum.py http://target.com --max-users=10 [*] Found author #1 with slug user_smt [*] Found author #3 with slug blogsmt-com [*] Found author #9 with slug y-toma-fr [*] Found author #10 with slug p-tim-fr Or, with a shortcut: $ ./wordpress-enum.py http://target.com -m 10 If we removed the default value, we'd have to tell ten that we expect an int using python's typing: def main(url, max_users: int):","title":"Adding parameters"},{"location":"tutorial.html#get-username-from-the-redirect-page","text":"Generally, after the redirect, we land on the page describing the Wordpress author, and the HTML looks like: <html> ... <title>[name-of-user], author on Wordpress site<title> ... </html> As a result, we can follow the redirect; response = response.follow_redirect() and then use a CSS selector to extract the title's contents: title = response.select_one(\"title\").text As a result, we obtain the username @entry def main(url, max_users=100): session = ScopedSession(url) for id in range(max_users): response = session.get(\"/\", params={\"author\": id}) if response.is_redirect: redirect = response.headers[\"location\"] if \"/author/\" in redirect: slug = redirect.split(\"/\")[-2] response = response.follow_redirect() title = response.select_one(\"title\").text username = title.split(\",\", 1)[0] msg_info(f\"Found author #{id} with slug {slug}: {username}\") Let's refactor the code a little bit to remove indent: @entry def main(url, max_users=100): session = ScopedSession(url) for id in range(max_users): response = session.get(\"/\", params={\"author\": id}) if not response.is_redirect: continue redirect = response.headers[\"location\"] if not \"/author/\" in redirect: continue slug = redirect.split(\"/\")[-2] response = response.follow_redirect() username = response.select_one(\"title\").text.split(\",\", 1)[0] msg_info(f\"Found author #{id} with slug {slug}: {username}\")","title":"Get username from the redirect page"},{"location":"tutorial.html#running-requests-concurrently","text":"At the moment, we run each HTTP request one by one. We can improve the process by running them concurrently. There are several ways to do this, but since we want to keep each response, we can just use multi() : responses = session.multi().get(\"/\", params={\"author\": Multi(range(1, max_users+1))}) Session.multi() returns a list of responses, where each request is submitted once per value in the Multi() instance. Here, we thus get a request to /?author=1 , /?author=2 , etc. The requests are run concurrently. The requests are then returned in the same order as they were submitted. We then need to iterate over the responses as we did before: for id, response in enumerate(responses, start=1): ... We are here in a simple case were it is easy to find the id from the index of the response in the list: the n th response corresponds to id n . However, sometimes the multis might not be numerical; you can also get this value from the tag element of the response: for response in responses: id = response.tag[\"params\", \"author\"] ...","title":"Running requests concurrently"},{"location":"tutorial.html#let-user-pick-number-of-connections","text":"By default, a session maintains, at most, 10 concurrent connections. We might want to let the user pick this themselves: @entry def main(url, max_users=100, max_connections=10): session = ScopedSession(url, max_connections=max_connections)","title":"Let user pick number of connections"},{"location":"tutorial.html#allow-for-a-proxy","text":"While attacking stuff on the internet, you often need to use proxies. Setting Session.proxies to a string automatically uses it for all requests: @entry def main(url, max_users=100, max_connections=10, proxy=None): session = ScopedSession(url, max_connections=max_connections) session.proxies = proxy We now have a pretty clean script with a few customizable options. Let's make the script ready for release with a cleaner GUI, documentation, etc.","title":"Allow for a proxy"},{"location":"tutorial.html#add-a-progress-bar","text":"Multi can display a progress bar indicating its progress. Simply add a description argument describing what is happening: @entry def main(url, max_users=100, max_connections=10): session = ScopedSession(url, max_connections=max_connections) responses = session.multi( description=\"Bruteforcing author IDs\" ).get(\"/\", params={\"author\": Multi(range(max_users))}) Now, you get a beautiful progress bar while the process is running. The second step of the exploitation, which resolves the redirects, should be faster, so it does not need a progress bar. Let's just add a spinner to point out that it is running: with msg_status(\"Resolving usernames...\"): for response in responses: ...","title":"Add a progress bar"},{"location":"tutorial.html#documentation","text":"Our program is now fast and it looks good. We need to handle the most dreaded step of development: documentation. If we run --help right now, we get the strict minimum: ./wordpress-enum.py --help Usage: wordpress-enum.py [-h] [-m MAX_USERS] [-M MAX_CONNECTIONS] [-p PROXY] url Positional Arguments: url Options: -h, --help show this help message and exit -m, --max-users MAX_USERS -M, --max-connections MAX_CONNECTIONS -p, --proxy PROXY We'll document the script and its parameters in a blink. Let's start by adding a documentation to the main entrypoint. @entry def main(url, max_users=100, max_connections=10, proxy=None): \"\"\"Obtains Wordpress user slugs and usernames by bruteforcing author IDs. \"\"\" The help message gets a little bit better. However, we should also document arguments. This can be done by using arg(\"name\", \"description\") : @entry @arg(\"url\", \"URL of the WP website\") @arg(\"max_users\", \"Maximum amount of user IDs to bruteforce\") @arg(\"max_connections\", \"Maximum number of concurrent connections\") @arg(\"proxy\", \"Optional proxy to use\") def main(url, max_users=100, max_connections=10, proxy=None): \"\"\"Obtains Wordpress user slugs and usernames by bruteforcing author IDs. \"\"\" That's it ! Our program is documented, and ready for release. ./wordpress-enum.py --help Usage: wordpress-enum.py [-h] [-m MAX_USERS] [-M MAX_CONNECTIONS] [-p PROXY] url Obtains Wordpress user slugs and usernames by bruteforcing author IDs. Positional Arguments: url URL of the WP website Options: -h, --help show this help message and exit -m, --max-users MAX_USERS Maximum amount of user IDs to bruteforce -M, --max-connections MAX_CONNECTIONS Maximum number of concurrent connections -p, --proxy PROXY Optional proxy to use We are ready to go ! Here's the final script: #!/usr/bin/env python3 from ten import * @entry @arg(\"url\", \"URL of the WP website\") @arg(\"max_users\", \"Maximum amount of user IDs to bruteforce\") @arg(\"max_connections\", \"Maximum number of concurrent connections\") @arg(\"proxy\", \"Optional proxy to use\") def main(url, max_users=100, max_connections=10, proxy=None): \"\"\"Obtains Wordpress user slugs and usernames by bruteforcing author IDs. \"\"\" session = ScopedSession(url, max_connections=max_connections) session.proxies = proxy responses = session.multi( description=\"Bruteforcing author IDs\" ).get(\"/\", params={\"author\": Multi(range(max_users))}) with msg_status(\"Resolving usernames...\"): for response in responses: id = response.tag[\"params\", \"author\"] if not response.is_redirect: continue redirect = response.headers[\"location\"] if not \"/author/\" in redirect: continue slug = redirect.split(\"/\")[-2] response = response.follow_redirect() username = response.select_one(\"title\").text.split(\",\", 1)[0] msg_info(f\"Found author #{id} with slug {slug}: {username}\") main()","title":"Documentation"}]}